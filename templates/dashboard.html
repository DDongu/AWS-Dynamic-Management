<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AWS EC2 MANAGER</title>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3/build/web/hack.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <link rel="stylesheet" href="../static/css/styles.css">
  <link rel="stylesheet" href="../static/css/sidebar.css">
  <link rel="stylesheet" href="../static/css/dashboard.css">
</head>
<body>
    <div class="container">

        {% include 'sidebar.html' %}
        
        <div class="content">
            <div>
                <h1><a href="/dashboard">Dashboard</a></h1>
                    <select id="instanceOptions" name="instance_id" onchange="getMetrics()">
                        {% for instance in instances %}
                            <option value="{{ instance.id }}">{{ instance.id }} (NAME: {{ instance.name }} )</option>
                        {% endfor %}
                    </select>


                <div class="chart-container">
                    <canvas id="Graph" width="800" height="400"></canvas>
                    <div class="legend">
                        <span><span class="legend-color" style="background: #4e79a7;"></span>Average</span>
                        <span><span class="legend-color" style="background: #f28e2c;"></span>Maximum</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        function submitForm() {
            document.getElementById('instanceForm').submit();
        }
    </script>
</body>
<script>
    let cpuData = [];
 
    const canvas = document.getElementById('Graph');
    const ctx = canvas.getContext('2d');

    /* 그래프 그리는 함수 */
    function drawGraph(rawData) {
        console.log("rawData:", rawData);

        const padding = 60; // 그래프 여백 
        const leftRightPadding = 25; // 그래프 왼쪽 여백
        const chartWidth = canvas.width - (padding * 2); // 그래프 너비
        const chartHeight = canvas.height - (padding * 2); // 그래프 높이
 
        // 최대값 찾아서 Y축 최대 높이 계산
        const maxValue = parseFloat(Math.max(...rawData.map(d => Math.max(d.Maximum, d.Average))));
        const yScale = chartHeight / maxValue;
        console.log("maxValue:", maxValue);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        
        /* 그래프 안에 그리드 그리는 함수 */
        function drawGrid() {
            const gridLines = 10; // 그리드 라인 수
            ctx.beginPath();
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
 
            for(let i = 0; i <= gridLines; i++) {
                const y = padding + (chartHeight / gridLines) * i;
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding + 50, y);
                
                // Y축 값 표시
                const value = parseFloat(((gridLines - i) * maxValue / gridLines)).toFixed(1);
                ctx.fillStyle = '#666';
                ctx.textAlign = 'right';
                ctx.fillText(value + '%', padding - 5, y + 4);
            }
            ctx.stroke();
        }
        drawGrid();

        // X, Y축 세팅
        ctx.beginPath();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        // Y축 그리기
        ctx.moveTo(padding, padding - 10); // 해당 값을 조정해 Y축 조절
        ctx.lineTo(padding, canvas.height - padding);
        // X축 그리기
        ctx.moveTo(padding, canvas.height - padding);
        ctx.lineTo(canvas.width - padding + 50, canvas.height - padding); // 해당 값을 조정해 X축 조절
        ctx.stroke();
 
        
        /* 그래프 안에 선 그리는 함수 */
        function drawLine(data, field, color) {
            // 선 그리기
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
 
            data.forEach((item, index) => {
                const x = leftRightPadding + padding + (index * (chartWidth / (data.length > 1 ? (data.length - 1) : 1))); // 데이터가 하나인 경우에 대한 예외 처리 추가
                const y = canvas.height - padding - (item[field] * yScale);
 
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();  // 라인 그리기
 
            // 데이터 포인트 찍기
            data.forEach((item, index) => {
                const x = leftRightPadding + padding + (index * (chartWidth / (data.length > 1 ? (data.length - 1) : 1))); // 데이터가 하나인 경우에 대한 예외 처리 추가
                const y = canvas.height - padding - (item[field] * yScale);
 
                // 포인트 그리기
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.stroke();
 
                // 값 표시
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.fillText(parseFloat(item[field]).toFixed(2) + '%', x, y - 10);
            });
        }
 
        // Average와 Maximum 라인 그리기
        drawLine(rawData, 'Average', '#4e79a7');
        drawLine(rawData, 'Maximum', '#f28e2c');
 
        // X축 날짜 레이블
        rawData.forEach((item, index) => {
            const x = leftRightPadding + padding + (index * (chartWidth / (rawData.length > 1 ? (rawData.length - 1) : 1)));
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            const date = new Date(item.Timestamp);
            const label = `${date.getMonth() + 1}/${date.getDate()}`;
            ctx.fillText(label, x, canvas.height - padding + 20);
        });
    }


    /* 메트릭 데이터 가져오는 함수(POST 요청) */
    function getMetrics() {
        const instanceId = document.getElementById("instanceOptions").value;

        fetch("/get_metrics", {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
            },
            body: new URLSearchParams({
                "instance_id": instanceId,
            }),
        })
        .then(response => response.json())
        .then(data => {
            cpuData = data.cpu_data;
            console.log("CPU Data:", cpuData);
            // 그래프 그리는 함수 호출
            drawGraph(cpuData);
        })
        .catch(error => console.error("Error fetching metrics:", error));
    }
 </script>
</html>
